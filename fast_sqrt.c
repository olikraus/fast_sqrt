/*

  fast_sqrt.c
  
  Copyright (c) 2021, olikraus@gmail.com

  Redistribution and use in source and binary forms, with or without modification, are 
  permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice, this list of 
  conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright notice, this list of 
  conditions and the following disclaimer in the documentation and/or other materials 
  provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/
#include <stdint.h>

#define INPUT_COMMA 15
#define INPUT_ONE (1UL<<INPUT_COMMA)
#define INTERNAL_COMMA 14
#define INTERNAL_ONE (1UL<<INTERNAL_COMMA)

#define SQRT_START_BITS 4
#define SQRT_START_CNT (1<<SQRT_START_BITS)

#ifdef __GNUC__
#define USE_BUILDIN_CLZ
#endif


/* this table is generated by calculate_start_values.c */
static uint16_t sqrt_start_values[16] = {24241, 31925, 45989, 38100, 33294, 29975, 27506, 25577, 24017, 22720, 21621, 20674, 19846, 19115, 18463, 17876};


#ifndef USE_BUILDIN_CLZ
// find the log base 2 of 32-bit v
int get_highest_1_bit_position(uint32_t v)
{
  // source: http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn
  
  static const uint8_t MultiplyDeBruijnBitPosition[32] = 
  {
    0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
    8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31
  };

  v |= v >> 1; // first round down to one less than a power of 2 
  v |= v >> 2;
  v |= v >> 4;
  v |= v >> 8;
  v |= v >> 16;

  return MultiplyDeBruijnBitPosition[(uint32_t)(v * 0x07C4ACDDU) >> 27];
}
#endif


/*
  Prototype:
    uint16_t fast_sqrt(int16_t number)
  Description:
    Calculate the square root for a 1.15 fix point value
    Valid input values are from 0 to 0x7fff (0 to .9999694824).
  Arg
    number: A 1.15 fix point value from which the square root is calculated
  Returns
    The square root of "number" or 0 if the "number" is negative
*/

int16_t fast_sqrt(int16_t n)
{
  uint32_t temp;
  uint32_t x;  
  int number_up_shift = 0;
  int highest_bit_position;
  uint16_t number = n;
  
  /*
    Check whether the input is negative. If so, return 0.
  */
  if ( number < 0 )
    return 0;

  /*
    The following block increases accuracy by shifting up small values.
    Idea: sqrt(n) == sqrt(4*n/4) == sqrt(4*n)/2
    Instead of calculating sqrt(n), calculate sqrt(4*n) and divide by 2 at the end.
    For the implementation a more general approach is used: sqrt(2^(2*s) * n) / 2^s
  
    In the first step, calculate the position of the highest one-bit. 
    Some architectures provide a "count left zeros" function, which could be used to get the highest one bit.-
  */
#ifndef USE_BUILDIN_CLZ
  highest_bit_position = get_highest_1_bit_position(number);
#else
  highest_bit_position = INPUT_COMMA;
  if ( number > 0 )
    highest_bit_position  = 31-__builtin_clz(number);
  else
    highest_bit_position  = 31;
#endif  
  /*
    Upshift is only possible if the highes one bit is more than 2 bit positions below the comma of the input value
  */
  if ( INPUT_COMMA >= highest_bit_position + 2 )
  {
    number_up_shift = INPUT_COMMA - highest_bit_position - 2;         /* Calculate the number of left shifts */
    number_up_shift &= 0x0fe;                           /* Ensure that the number is even, so that we can fix the left shift of the result later */
    number <<= number_up_shift;                         /* Do the upshift */
    number_up_shift /= 2;                                       /* Calculate the value for the down shift of the result: Downshift is half of the upshift */
  }

  /*
    Find a suitable starting point for the approximation process defined by
          x := x + x*(1-d*x*x)/2 
    This iterative approximation will calculate the inverse square root of x (1/sqrt(x))
    The initial 16 values for x are the  following values:
      0 0000 000 00000000
      0 0001 000 00000000
      0 0011 000 00000000
      ...
      0 1111 000 00000000
    The lookup table sqrt_start_values will return the precalculated result (inverse square root).
  
    The following iteration process will use a different fix point format 2.14.
    Values within sqrt_start_values are already in 2.14 format.
  */
  
  x = sqrt_start_values[number >> (INPUT_COMMA - SQRT_START_BITS)];     /* fix-point 2.14 */
  
  /* 
    Calculate the ivnerse square root by using the following iterative approximation:
        x := x + x*(1-d*x*x)/2 (https://www.jjj.de/fxt/fxtbook.pdf, page 568)
    By restructuring the expression, we can remove one add operation:    
      x := x + x*(1-d*x*x)/2 
      x := x * ( 1 + (1-d*x*x)/2 )
      x := x * ( 1 + 0.5 - d*x*x/2 )
      
  */
  
  /* iteration 1 */
  temp = x;                                     /* x is already in 2.14 format */
  temp *= x;                                    /* 2.14 * 2.14 */
  temp >>= INTERNAL_COMMA;      /* shift by 14 to get 2.14 format */
  
  temp *= number;                               /* d*x*x/2: 1.15 * 2.14 */
  temp >>= INPUT_COMMA+1;           /* to get the 2.14 format, shift by 15 (1.15) and additionally divide by 2 ("+1") */ 
  
  temp = INTERNAL_ONE + (INTERNAL_ONE>>1) - temp;   /* 1 + 0.5 - d*x*x/2 */
  x *= temp;                                            /* 2.14 * 2.14 */
  x >>= INTERNAL_COMMA;                  /* shift by 14 to get 2.14 format */

  /* iteration 2 */
  temp = x;
  temp *= x;
  temp >>= INTERNAL_COMMA;
  
  temp *= number;
  temp >>= INPUT_COMMA+1;
  
  temp = INTERNAL_ONE + (INTERNAL_ONE>>1) - temp;
  x *= temp;
  x >>= INTERNAL_COMMA;

  /* iteration 3 */
  temp = x;
  temp *= x;
  temp >>= INTERNAL_COMMA;
  
  temp *= number;
  temp >>= INPUT_COMMA+1;
  
  temp = INTERNAL_ONE + (INTERNAL_ONE>>1) - temp;
  x *= temp;
  x >>= INTERNAL_COMMA;

  /*
    "x" contains the inverse root 1/sqrt(number).
      x = 1/sqrt(number)
    If we multiple both sides with "number", then we get sqrt(number):
      x*number = 1/sqrt(number)*number = sqrt(number)
  */

  x *= number;  /* fix-point: 1.15 * 2.14 */
  
  /*
    The previous multiplication has to be corrected by the internal 2.14 fix point to get the 1.15 format.
    Additionally undo the initial up shift of the input value.
  */
  x >>= INTERNAL_COMMA+number_up_shift;
  
  /* 
    At this point the error might be up to two bits.
    Perform a final increase in the precision, by comparing the quadric value with the original number.
    For this purpose we store the square in temp and the difference in "n".
    
    This section is optional, but will increase precision of the result a little bit.
  */
  temp = x;
  temp *= x;                                    /* square value of x */
  temp >>= INPUT_COMMA;         /* square value of x in 1.15 format */
  n -= temp;                                    /* reuse n to store the signed difference */
     
  if ( n > 1 || n < -1 )                      /* update result only if the current difference is larger than 1 */
    x += n>>1;
  
  /* finally return the square root of the input value */
  return x;
}
